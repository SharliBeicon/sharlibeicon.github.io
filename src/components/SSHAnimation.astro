---
const animationSteps = [
  {
    prompt: "user@local-machine:~$",
    command: "ssh charliebacon.dev",
    delay: 1000,
  },
  {
    text: `The authenticity of host 'charliebacon.dev (192.168.1.100)' can't be established.`,
    color: "var(--yellow)",
    delay: 10,
  },
  {
    text: `RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.`,
    color: "var(--fg0)",
    delay: 10,
  },
  {
    text: `Are you sure you want to continue connecting (yes/no/[fingerprint])? `,
    color: "var(--fg0)",
    delay: 1200,
    waitForInput: true,
  },
  {
    response: "yes",
    delay: 800,
  },
  {
    text: `Warning: Permanently added 'charliebacon.dev' (RSA) to the list of known hosts.`,
    color: "var(--yellow)",
    delay: 1000,
  },
  {
    text: `Welcome to Charlie's Portfolio Terminal!`,
    color: "var(--green)",
    delay: 1200,
  },
  {
    text: `Type 'help' to see available commands.`,
    color: "var(--fg2)",
    delay: 1200,
  },
  {
    text: `Connection established. Loading terminal...`,
    color: "var(--fg2)",
    delay: 1500,
    final: true,
  },
];

const animationConfig = {
  initialDelay: 500,
  typingSpeed: {
    min: 80,
    max: 160,
  },
  cursor: "█",
  responseDelay: 300,
  finalizeDelay: 500,
};
---

<div
  id="ssh-animation"
  class="h-full flex flex-col bg-[var(--background0)] text-[var(--fg0)]"
  data-animation-steps={JSON.stringify(animationSteps)}
  data-animation-config={JSON.stringify(animationConfig)}
>
  <div id="ssh-output" class="flex-1 overflow-y-auto px-4 py-4"></div>
</div>

<script>
  // Get data from HTML attributes
  const animationElement = document.querySelector(
    "#ssh-animation",
  ) as HTMLElement;
  const animationSteps = JSON.parse(
    animationElement.dataset.animationSteps || "[]",
  );
  const animationConfig = JSON.parse(
    animationElement.dataset.animationConfig || "{}",
  );

  document.addEventListener("DOMContentLoaded", () => {
    const sshOutput = document.getElementById("ssh-output");
    let step = 0;

    const animationHelpers = {
      addLine: (content: string, className = "") => {
        if (sshOutput) {
          const line = document.createElement("div");
          line.innerHTML = content;
          line.className = className;
          sshOutput.appendChild(line);
          sshOutput.scrollTop = sshOutput.scrollHeight;
        }
      },

      getTypingDelay: () => {
        const { min, max } = animationConfig.typingSpeed;
        return min + Math.random() * (max - min);
      },

      typeCommand: (prompt: string, command: string, callback: () => void) => {
        let currentText = "";
        let index = 0;

        // Add prompt
        const promptLine = document.createElement("div");
        promptLine.className = "";
        sshOutput?.appendChild(promptLine);

        function typeNextChar() {
          if (index < command.length) {
            currentText += command[index];
            promptLine.innerHTML = `<span style="color: var(--blue)">${prompt}</span> ${currentText}<span>${animationConfig.cursor}</span>`;
            index++;
            setTimeout(typeNextChar, animationHelpers.getTypingDelay());
          } else {
            // Remove cursor and finalize
            promptLine.innerHTML = `<span style="color: var(--blue)">${prompt}</span> ${currentText}`;
            setTimeout(callback, animationConfig.finalizeDelay);
          }
        }

        // Start with just the prompt and cursor
        promptLine.innerHTML = `<span style="color: var(--blue)">${prompt}</span> <span>${animationConfig.cursor}</span>`;
        setTimeout(typeNextChar, animationConfig.finalizeDelay);
      },

      typeResponse: (
        response: string,
        originalContent: string,
        lastLine: HTMLElement,
        callback: () => void,
      ) => {
        let currentResponse = "";
        let index = 0;

        function typeResponseChar() {
          if (index < response.length && lastLine) {
            currentResponse += response[index];
            lastLine.innerHTML = `${originalContent}${currentResponse}<span>${animationConfig.cursor}</span>`;
            index++;
            setTimeout(typeResponseChar, animationHelpers.getTypingDelay());
          } else if (lastLine) {
            // Remove cursor and finalize
            lastLine.innerHTML = `${originalContent}${currentResponse}`;
            callback();
          }
        }

        setTimeout(typeResponseChar, animationConfig.responseDelay);
      },
    };

    function runAnimation() {
      const currentStep = animationSteps[step];

      if (currentStep.prompt && currentStep.command) {
        animationHelpers.typeCommand(
          currentStep.prompt,
          currentStep.command,
          () => {
            step++;
            setTimeout(runAnimation, currentStep.delay);
          },
        );
      } else if (currentStep.response) {
        // Simulate typing the response letter by letter
        const response = currentStep.response;
        const lastLine = sshOutput?.lastElementChild as HTMLElement;

        if (!lastLine) return;

        const originalContent = lastLine.innerHTML.replace(
          /<span class="cursor-inline">█<\/span>/,
          "",
        );

        animationHelpers.typeResponse(
          response,
          originalContent,
          lastLine,
          () => {
            step++;
            setTimeout(runAnimation, currentStep.delay);
          },
        );
      } else if (currentStep.text) {
        // Add system message - display instantly for SSH output
        const color = currentStep.color || "var(--fg0)";
        animationHelpers.addLine(
          `<span style="color: ${color}">${currentStep.text}</span>`,
        );

        if (currentStep.waitForInput) {
          // Simulate user thinking and then typing response
          setTimeout(() => {
            step++;
            runAnimation();
          }, currentStep.delay);
        } else if (currentStep.final) {
          // Final step - trigger transition to main terminal
          setTimeout(() => {
            const event = new CustomEvent("ssh-animation-complete");
            document.dispatchEvent(event);
          }, currentStep.delay);
        } else {
          step++;
          setTimeout(runAnimation, currentStep.delay);
        }
      }
    }

    setTimeout(() => {
      runAnimation();
    }, animationConfig.initialDelay);
  });
</script>
